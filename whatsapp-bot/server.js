require('dotenv').config();
const express = require('express');
const cors = require('cors');
const pino = require('pino');
const fs = require('fs');
const path = require('path');
const {
    default: makeWASocket,
    useMultiFileAuthState,
    DisconnectReason,
    fetchLatestBaileysVersion,
    jidNormalizedUser
} = require('@whiskeysockets/baileys');
const qrcode = require('qrcode');
const axios = require('axios');

const logger = pino({ level: 'info' });
const app = express();
const PORT = process.env.PORT || 3000;
const LARAVEL_URL = process.env.LARAVEL_URL || 'http://localhost:89';


app.use(cors());
app.use(express.json());

/**
 * ‰ºöËØùÁÆ°ÁêÜÔºö
 * sessions: Map<sessionId, { sock, state, saveCreds, status, lastQR }>
 * status: 'connecting' | 'open' | 'close'
 */
const sessions = new Map();

const SESSIONS_DIR = path.join(__dirname, 'sessions');
if (!fs.existsSync(SESSIONS_DIR)) fs.mkdirSync(SESSIONS_DIR, { recursive: true });

/** Â∑•ÂÖ∑ÂáΩÊï∞ */
const ensureGroupId = (gid) => gid.endsWith('@g.us') ? gid : `${gid}@g.us`;
const phoneToUserJid = (phone) => {
    const digits = (phone || '').replace(/\D/g, '');
    return `${digits}@s.whatsapp.net`;
};
const jidToPhone = (jid) => (jid || '').split('@')[0];

/** ÂàõÂª∫ Laravel API ËØ∑Ê±ÇÈÖçÁΩÆ */
const createLaravelConfig = () => ({
    timeout: 15000,
    headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
});

/** ÂèëÈÄÅÁä∂ÊÄÅÂà∞ Laravel */
async function sendStatusToLaravel(sessionId, status, phoneNumber = null, message = null) {
    try {
        await axios.post(`${LARAVEL_URL}/api/bots/${sessionId}/status`, {
            status: status,
            phone_number: phoneNumber,
            message: message
        }, createLaravelConfig());
        console.log(`‚úÖ Êú∫Âô®‰∫∫ #${sessionId} Áä∂ÊÄÅÂ∑≤Êõ¥Êñ∞Âà∞ Laravel: ${status}`);
    } catch (error) {
        console.error(`‚ùå Êõ¥Êñ∞Êú∫Âô®‰∫∫ #${sessionId} Áä∂ÊÄÅÂà∞ Laravel Â§±Ë¥•: ${error.message}`);
        console.error(`‚ùå ÈîôËØØËØ¶ÊÉÖ: ${error.response?.status} - ${error.response?.statusText}`);
    }
}

/** ÂèëÈÄÅ‰∫åÁª¥Á†ÅÂà∞ Laravel */
async function sendQrCodeToLaravel(sessionId, qrCode) {
    try {
        await axios.post(`${LARAVEL_URL}/api/bots/${sessionId}/qr-code`, {
            qrCode: qrCode
        }, createLaravelConfig());
        console.log(`‚úÖ Êú∫Âô®‰∫∫ #${sessionId} QR Á†ÅÂ∑≤ÂèëÈÄÅÂà∞ Laravel`);
    } catch (error) {
        console.error(`‚ùå ÂèëÈÄÅÊú∫Âô®‰∫∫ #${sessionId} QR Á†ÅÂà∞ Laravel Â§±Ë¥•: ${error.message}`);
        console.error(`‚ùå ÈîôËØØËØ¶ÊÉÖ: ${error.response?.status} - ${error.response?.statusText}`);
    }
}

/** Âª∫Á´ã/Ëé∑Âèñ‰∏Ä‰∏™‰ºöËØùÔºà‰∏çÂ≠òÂú®ÂàôÂàõÂª∫Âπ∂ËøûÊé•Ôºâ */
async function getOrCreateSession(sessionId) {
    if (sessions.has(sessionId)) {
        const existingSession = sessions.get(sessionId);
        if (existingSession.status === 'connecting') {
            console.log(`‚è≥ Êú∫Âô®‰∫∫ #${sessionId} Ê≠£Âú®ËøûÊé•‰∏≠ÔºåÁ≠âÂæÖÂÆåÊàê...`);
            return existingSession;
        }
        return existingSession;
    }

    console.log(`ü§ñ Ê≠£Âú®‰∏∫Êú∫Âô®‰∫∫ #${sessionId} ÂàõÂª∫Êñ∞‰ºöËØù`);
    
    const sessionPath = path.join(SESSIONS_DIR, sessionId);
    const { state, saveCreds } = await useMultiFileAuthState(sessionPath);
    const { version } = await fetchLatestBaileysVersion();

    const socketConfig = {
        version,
        auth: state,
        printQRInTerminal: false,
        browser: ['Chrome', 'Windows', '10.0.0'],
        logger: pino({ level: 'info' }),
        connectTimeoutMs: 60000,
        defaultQueryTimeoutMs: 0,
        keepAliveIntervalMs: 30000,
        retryRequestDelayMs: 250,
        maxMsgRetryCount: 5,
        markOnlineOnConnect: true,
        syncFullHistory: false,
        fireInitQueries: true,
        generateHighQualityLinkPreview: false,
        getMessage: async (key) => {
            return {
                conversation: 'Hello'
            };
        }
    };


    const sock = makeWASocket(socketConfig);

    const ctx = {
        sock,
        state,
        saveCreds,
        status: 'connecting',
        lastQR: null
    };
    sessions.set(sessionId, ctx);

    // ÁõëÂê¨Âá≠ÊçÆÊõ¥Êñ∞
    sock.ev.on('creds.update', saveCreds);

    // ËøûÊé•Áä∂ÊÄÅ & ‰∫åÁª¥Á†Å
    sock.ev.on('connection.update', async (update) => {
        const { connection, qr, lastDisconnect, isNewLogin } = update;

        console.log(`üìä Êú∫Âô®‰∫∫ #${sessionId} ËøûÊé•Áä∂ÊÄÅÊõ¥Êñ∞: ${connection || 'unknown'}`);

        if (qr) {
            console.log(`üì± Êú∫Âô®‰∫∫ #${sessionId} Êî∂Âà∞ QR Á†Å`);
            try {
                // ÁîüÊàê base64 dataURL
                ctx.lastQR = await qrcode.toDataURL(qr);
                await sendQrCodeToLaravel(sessionId, ctx.lastQR);
                await sendStatusToLaravel(sessionId, 'connecting', null, 'Á≠âÂæÖÊâ´Á†ÅÁôªÂΩï');
            } catch (e) {
                console.error('‚ùå QR Á†ÅÁîüÊàêÂ§±Ë¥•:', e.message);
            }
        }

        if (connection === 'open') {
            ctx.status = 'open';
            ctx.lastQR = null;
            const phoneNumber = sock.user.id.split(':')[0];
            const pushname = sock.user.name || null;
            
            console.log(`‚úÖ Êú∫Âô®‰∫∫ #${sessionId} ËøûÊé•ÊàêÂäüÔºÅÊâãÊú∫Âè∑: ${phoneNumber}, ÊòµÁß∞: ${pushname || 'Êú™ËÆæÁΩÆ'}`);
            await sendStatusToLaravel(sessionId, 'online', phoneNumber, 'ËøûÊé•ÊàêÂäü');
        }

        if (connection === 'close') {
            const reason = lastDisconnect?.error?.output?.statusCode || lastDisconnect?.error?.reason || 'unknown';
            const shouldReconnect = (lastDisconnect?.error)?.output?.statusCode !== DisconnectReason.loggedOut;
            
            console.log(`‚ùå Êú∫Âô®‰∫∫ #${sessionId} ËøûÊé•Êñ≠ÂºÄÔºåÂéüÂõ†: ${reason}ÔºåÊòØÂê¶ÈáçËøû: ${shouldReconnect ? 'ÊòØ' : 'Âê¶'}`);
            ctx.status = 'close';
            
            if (shouldReconnect) {
                await sendStatusToLaravel(sessionId, 'offline', null, `ËøûÊé•Êñ≠ÂºÄÔºåÂ∞ùËØïÈáçËøû‰∏≠...`);
                
                // Âª∂ËøüÈáçËøû
                setTimeout(async () => {
                    try {
                        console.log(`üîÑ Êú∫Âô®‰∫∫ #${sessionId} Â∞ùËØïÈáçËøû...`);
                        await sendStatusToLaravel(sessionId, 'connecting', null, 'Ê≠£Âú®ÈáçËøû...');
                        await getOrCreateSession(sessionId);
                    } catch (error) {
                        console.error(`‚ùå Êú∫Âô®‰∫∫ #${sessionId} ÈáçËøûÂ§±Ë¥•: ${error.message}`);
                        await sendStatusToLaravel(sessionId, 'error', null, `ÈáçËøûÂ§±Ë¥•: ${error.message}`);
                    }
                }, 5000); // 5ÁßíÂêéÈáçËøû
            } else {
                await sendStatusToLaravel(sessionId, 'offline', null, 'Â∑≤ÁôªÂá∫');
                // Âà†Èô§‰ºöËØù
                sessions.delete(sessionId);
            }
        }
    });

    return ctx;
}

/** API Á´ØÁÇπ */

// ÂÅ•Â∫∑Ê£ÄÊü•
app.get('/', (req, res) => {
    res.json({
        success: true,
        message: 'WhatsApp Êú∫Âô®‰∫∫ÊúçÂä°Âô®ËøêË°å‰∏≠',
        version: '2.0.0',
        runningSessions: sessions.size
    });
});

// ÂàóÂá∫ÊâÄÊúâ‰ºöËØù
app.get('/sessions', async (req, res) => {
    const list = [];
    for (const [sessionId, ctx] of sessions.entries()) {
        list.push({ 
            sessionId, 
            status: ctx.status || 'connecting', 
            hasQR: !!ctx.lastQR 
        });
    }
    res.json({ success: true, data: { total: sessions.size, sessions: list } });
});

// Ëé∑Âèñ‰∫åÁª¥Á†ÅÔºàËß¶ÂèëÁôªÂΩïÊµÅÁ®ãÔºâ
app.get('/sessions/:sessionId/qr', async (req, res) => {
    try {
        const { sessionId } = req.params;
        const ctx = await getOrCreateSession(sessionId);
        res.json({
            success: true,
            sessionId,
            status: ctx.status,
            qr: ctx.lastQR
        });
    } catch (e) {
        console.error('‚ùå Ëé∑Âèñ QR Á†ÅÂ§±Ë¥•:', e.message);
        res.status(500).json({ 
            success: false, 
            error: 'failed_to_get_qr', 
            detail: String(e?.message || e) 
        });
    }
});

// Ëé∑Âèñ‰ºöËØùÁä∂ÊÄÅ
app.get('/sessions/:sessionId/status', async (req, res) => {
    try {
        const { sessionId } = req.params;
        const ctx = await getOrCreateSession(sessionId);
        res.json({ 
            success: true, 
            sessionId, 
            status: ctx.status, 
            hasQR: !!ctx.lastQR 
        });
    } catch (e) {
        console.error('‚ùå Ëé∑Âèñ‰ºöËØùÁä∂ÊÄÅÂ§±Ë¥•:', e.message);
        res.status(500).json({ 
            success: false, 
            error: 'failed_to_get_status', 
            detail: String(e?.message || e) 
        });
    }
});

// ÂÅúÊ≠¢‰ºöËØù
app.post('/sessions/:sessionId/stop', async (req, res) => {
    try {
        const { sessionId } = req.params;
        const ctx = sessions.get(sessionId);
        
        if (ctx) {
            await ctx.sock.logout();
            sessions.delete(sessionId);
            console.log(`‚úÖ ‰ºöËØù #${sessionId} Â∑≤ÂÅúÊ≠¢Âπ∂ÁßªÈô§`);
            await sendStatusToLaravel(sessionId, 'offline', null, 'Áî®Êà∑ÊâãÂä®ÂÅúÊ≠¢');
        }
        
        res.json({ success: true, message: '‰ºöËØùÂ∑≤ÂÅúÊ≠¢' });
    } catch (e) {
        console.error('‚ùå ÂÅúÊ≠¢‰ºöËØùÂ§±Ë¥•:', e.message);
        res.status(500).json({ 
            success: false, 
            error: 'failed_to_stop_session', 
            detail: String(e?.message || e) 
        });
    }
});

// Ëé∑ÂèñÁæ§ÁªÑÂàóË°®
app.get('/sessions/:sessionId/groups', async (req, res) => {
    try {
        const { sessionId } = req.params;
        const ctx = await getOrCreateSession(sessionId);
        
        if (ctx.status !== 'open') {
            return res.status(409).json({ 
                success: false, 
                error: 'not_connected', 
                message: 'session not connected yet' 
            });
        }

        const groupsDict = await ctx.sock.groupFetchAllParticipating();
        const groups = Object.values(groupsDict).map(g => ({
            id: g.id,
            subject: g.subject,
            size: g.participants?.length || 0
        }));

        // ÂêåÊ≠•Âà∞ Laravel
        for (const group of groups) {
            try {
                await axios.post(`${LARAVEL_URL}/api/bots/${sessionId}/sync-group`, {
                    groupId: group.id,
                    name: group.subject,
                    description: '',
                    memberCount: group.size
                }, createLaravelConfig());
            } catch (error) {
                console.error(`‚ùå ÂêåÊ≠•Áæ§ÁªÑ "${group.subject}" Âà∞ Laravel Â§±Ë¥•: ${error.message}`);
            }
        }

        res.json({ 
            success: true, 
            sessionId, 
            groups,
            syncedCount: groups.length 
        });
    } catch (e) {
        console.error('‚ùå Ëé∑ÂèñÁæ§ÁªÑÂàóË°®Â§±Ë¥•:', e.message);
        res.status(500).json({ 
            success: false, 
            error: 'failed_to_fetch_groups', 
            detail: String(e?.message || e) 
        });
    }
});

// Ëé∑ÂèñÊåáÂÆöÁæ§ÁªÑÁöÑÊàêÂëòÊâãÊú∫Âè∑
app.get('/sessions/:sessionId/groups/:groupId/members', async (req, res) => {
    try {
        const { sessionId, groupId } = req.params;
        const gid = ensureGroupId(groupId);

        const ctx = await getOrCreateSession(sessionId);
        if (ctx.status !== 'open') {
            return res.status(409).json({ 
                success: false, 
                error: 'not_connected', 
                message: 'session not connected yet' 
            });
        }

        const meta = await ctx.sock.groupMetadata(gid);
        const members = (meta.participants || []).map(p => {
            const jid = jidNormalizedUser(p.id);
            return {
                jid,
                phone: jidToPhone(jid),
                admin: p.admin || null,
                isAdmin: !!p.admin
            };
        });

        // ÂêåÊ≠•Âà∞ Laravel
        for (const member of members) {
            try {
                await axios.post(`${LARAVEL_URL}/api/bots/${sessionId}/sync-group-user-phone`, {
                    groupId: groupId,
                    phoneNumber: member.phone,
                    isAdmin: member.isAdmin,
                    joinedAt: new Date().toISOString()
                }, createLaravelConfig());
            } catch (error) {
                console.error(`‚ùå ÂêåÊ≠•ÊàêÂëò ${member.phone} Âà∞ Laravel Â§±Ë¥•: ${error.message}`);
            }
        }

        res.json({
            success: true,
            sessionId,
            groupId: meta.id,
            subject: meta.subject,
            count: members.length,
            syncedCount: members.length,
            members
        });
    } catch (e) {
        console.error('‚ùå Ëé∑ÂèñÁæ§ÁªÑÊàêÂëòÂ§±Ë¥•:', e.message);
        res.status(500).json({ 
            success: false, 
            error: 'failed_to_fetch_members', 
            detail: String(e?.message || e) 
        });
    }
});

// ÂÖºÂÆπ Laravel ÁöÑ API Á´ØÁÇπÔºà‰øùÊåÅÂêëÂêéÂÖºÂÆπÔºâ
app.post('/api/bot/:botId/start', async (req, res) => {
    const { botId } = req.params;
    console.log(`üì• Êî∂Âà∞ÂêØÂä®ËØ∑Ê±Ç - Êú∫Âô®‰∫∫ ID: ${botId}`);
    
    try {
        // ÂÖàÊ£ÄÊü•ÊòØÂê¶Â∑≤Êúâ‰ºöËØù
        if (sessions.has(botId)) {
            const existingSession = sessions.get(botId);
            console.log(`‚ÑπÔ∏è Êú∫Âô®‰∫∫ #${botId} Â∑≤Êúâ‰ºöËØùÔºåÁä∂ÊÄÅ: ${existingSession.status}`);
            return res.json({ 
                success: true, 
                message: `Êú∫Âô®‰∫∫Â∑≤Â≠òÂú®ÔºåÁä∂ÊÄÅ: ${existingSession.status}`, 
                data: { botId, status: existingSession.status } 
            });
        }
        
        await getOrCreateSession(botId);
        res.json({ success: true, message: 'Êú∫Âô®‰∫∫ÂêØÂä®‰∏≠...', data: { botId, status: 'connecting' } });
    } catch (error) {
        console.error(`‚ùå ÂêØÂä®Êú∫Âô®‰∫∫ #${botId} Â§±Ë¥•: ${error.message}`);
        res.status(500).json({ success: false, message: `ÂêØÂä®Êú∫Âô®‰∫∫Â§±Ë¥•: ${error.message}` });
    }
});

app.post('/api/bot/:botId/stop', async (req, res) => {
    const { botId } = req.params;
    console.log(`üõë Êî∂Âà∞ÂÅúÊ≠¢ËØ∑Ê±Ç - Êú∫Âô®‰∫∫ ID: ${botId}`);
    
    try {
        const ctx = sessions.get(botId);
        if (ctx) {
            await ctx.sock.logout();
            sessions.delete(botId);
            console.log(`‚úÖ Êú∫Âô®‰∫∫ #${botId} Â∑≤ÂÅúÊ≠¢`);
        }
        res.json({ success: true, message: 'Êú∫Âô®‰∫∫Â∑≤ÂÅúÊ≠¢' });
    } catch (error) {
        console.error(`‚ùå ÂÅúÊ≠¢Êú∫Âô®‰∫∫ #${botId} Â§±Ë¥•: ${error.message}`);
        res.status(500).json({ success: false, message: `ÂÅúÊ≠¢Êú∫Âô®‰∫∫Â§±Ë¥•: ${error.message}` });
    }
});

app.post('/api/bot/:botId/sync-groups', async (req, res) => {
    const { botId } = req.params;
    console.log(`üîÑ Êî∂Âà∞ÂêåÊ≠•Áæ§ÁªÑËØ∑Ê±Ç - Êú∫Âô®‰∫∫ ID: ${botId}`);
    
    try {
        const ctx = await getOrCreateSession(botId);
        if (ctx.status !== 'open') {
            return res.status(400).json({ success: false, message: 'Êú∫Âô®‰∫∫Êú™Âú®Á∫ø' });
        }

        const groupsDict = await ctx.sock.groupFetchAllParticipating();
        const groups = Object.values(groupsDict).map(g => ({
            id: g.id,
            subject: g.subject,
            size: g.participants?.length || 0
        }));

        let syncedCount = 0;
        for (const group of groups) {
            try {
                await axios.post(`${LARAVEL_URL}/api/bots/${botId}/sync-group`, {
                    groupId: group.id,
                    name: group.subject,
                    description: '',
                    memberCount: group.size
                }, createLaravelConfig());
                syncedCount++;
            } catch (error) {
                console.error(`‚ùå ÂêåÊ≠•Áæ§ÁªÑ "${group.subject}" Â§±Ë¥•: ${error.message}`);
            }
        }

        res.json({
            success: true,
            message: `ÊàêÂäüÂêåÊ≠• ${syncedCount} ‰∏™Áæ§ÁªÑ`,
            data: { groupCount: syncedCount, totalGroups: groups.length }
        });
    } catch (error) {
        console.error(`‚ùå ÂêåÊ≠•Êú∫Âô®‰∫∫ #${botId} Áæ§ÁªÑÂ§±Ë¥•: ${error.message}`);
        res.status(500).json({ success: false, message: `ÂêåÊ≠•Áæ§ÁªÑÂ§±Ë¥•: ${error.message}` });
    }
});

app.post('/api/bot/:botId/sync-group-users', async (req, res) => {
    const { botId } = req.params;
    const { groupId } = req.body;
    console.log(`üîÑ Êî∂Âà∞ÂêåÊ≠•Áæ§ÁªÑÁî®Êà∑ËØ∑Ê±Ç - Êú∫Âô®‰∫∫ ID: ${botId}, Áæ§ÁªÑ ID: ${groupId}`);

    try {
        const ctx = await getOrCreateSession(botId);
        if (ctx.status !== 'open') {
            return res.status(400).json({ success: false, message: 'Êú∫Âô®‰∫∫Êú™Âú®Á∫ø' });
        }

        const gid = ensureGroupId(groupId);
        const meta = await ctx.sock.groupMetadata(gid);
        const members = (meta.participants || []).map(p => {
            const jid = jidNormalizedUser(p.id);
            return {
                jid,
                phone: jidToPhone(jid),
                admin: p.admin || null,
                isAdmin: !!p.admin
            };
        });

        let syncedCount = 0;
        for (const member of members) {
            try {
                await axios.post(`${LARAVEL_URL}/api/bots/${botId}/sync-group-user-phone`, {
                    groupId: groupId,
                    phoneNumber: member.phone,
                    isAdmin: member.isAdmin,
                    joinedAt: new Date().toISOString()
                }, createLaravelConfig());
                syncedCount++;
            } catch (error) {
                console.error(`‚ùå ÂêåÊ≠•ÊàêÂëò ${member.phone} Â§±Ë¥•: ${error.message}`);
            }
        }

        res.json({
            success: true,
            message: `ÊàêÂäüÂêåÊ≠• ${syncedCount} ‰∏™Áî®Êà∑ÊâãÊú∫Âè∑`,
            data: {
                groupName: meta.subject,
                groupId: groupId,
                syncedCount: syncedCount,
                totalMembers: members.length
            }
        });
    } catch (error) {
        console.error(`‚ùå ÂêåÊ≠•Êú∫Âô®‰∫∫ #${botId} Áæ§ÁªÑÁî®Êà∑Â§±Ë¥•: ${error.message}`);
        res.status(500).json({ success: false, message: `ÂêåÊ≠•Áæ§ÁªÑÁî®Êà∑Â§±Ë¥•: ${error.message}` });
    }
});

// ÊµãËØïÁΩëÁªúËøûÊé•
async function testNetworkConnection() {
    try {
        console.log('üåê ÊµãËØïÁΩëÁªúËøûÊé•...');
        const response = await axios.get('https://web.whatsapp.com', { timeout: 10000 });
        console.log('‚úÖ WhatsApp Web ÂèØËÆøÈóÆ');
        return true;
    } catch (error) {
        console.error('‚ùå ÁΩëÁªúËøûÊé•ÊµãËØïÂ§±Ë¥•:', error.message);
        console.log('üí° ËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÊàñÈò≤ÁÅ´Â¢ôËÆæÁΩÆ');
        return false;
    }
}

// ÂêØÂä®ÊúçÂä°Âô®
app.listen(PORT, async () => {
    console.log('========================================');
    console.log(`üöÄ WhatsApp Êú∫Âô®‰∫∫ÊúçÂä°Âô®ËøêË°å‰∏≠`);
    console.log(`üì° Á´ØÂè£: ${PORT}`);
    console.log(`üåê API: http://localhost:${PORT}`);
    console.log('========================================');

    // ÊµãËØïÁΩëÁªúËøûÊé•
    await testNetworkConnection();

    // ÊÅ¢Â§çÁé∞Êúâ‰ºöËØù
    console.log('üîÑ Ê£ÄÊü•Áé∞Êúâ‰ºöËØù...');
    if (fs.existsSync(SESSIONS_DIR)) {
        const sessionDirs = fs.readdirSync(SESSIONS_DIR);
        for (const sessionDir of sessionDirs) {
            if (fs.statSync(path.join(SESSIONS_DIR, sessionDir)).isDirectory()) {
                console.log(`üîÑ ÂèëÁé∞Áé∞Êúâ‰ºöËØù: ${sessionDir}`);
                try {
                    await getOrCreateSession(sessionDir);
                } catch (error) {
                    console.error(`‚ùå ÊÅ¢Â§ç‰ºöËØù ${sessionDir} Â§±Ë¥•: ${error.message}`);
                }
            }
        }
    }
    console.log('‚úÖ ‰ºöËØùÊÅ¢Â§çÂÆåÊàê');
});

// ‰ºòÈõÖÂÖ≥Èó≠
process.on('SIGINT', async () => {
    console.log('\nüõë Ê≠£Âú®ÂÖ≥Èó≠ÊâÄÊúâ‰ºöËØù...');
    for (const [sessionId, ctx] of sessions.entries()) {
        try {
            await ctx.sock.logout();
            console.log(`‚úÖ ‰ºöËØù #${sessionId} Â∑≤ÂÅúÊ≠¢`);
        } catch (error) {
            console.error(`‚ùå ÂÅúÊ≠¢‰ºöËØù #${sessionId} Êó∂Âá∫Èîô: ${error.message}`);
        }
    }
    console.log('‚úÖ ÊâÄÊúâ‰ºöËØùÂ∑≤ÂÅúÊ≠¢ÔºåÊ≠£Âú®ÈÄÄÂá∫...');
    process.exit(0);
});